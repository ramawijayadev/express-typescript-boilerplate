<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>TypeScript Clean Code Constitution</title>
    <meta name="description"
        content="Strict coding standards and conventions for TypeScript development using Feature-Based Architecture.">
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            color: #333;
        }

        h1,
        h2,
        h3 {
            color: #111;
        }

        code {
            background: #f4f4f4;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
            color: #d63384;
        }

        pre {
            background: #f4f4f4;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
        }

        pre code {
            background: none;
            color: #333;
            padding: 0;
        }

        .badge {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .forbidden {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #ef9a9a;
        }

        .required {
            background: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #a5d6a7;
        }

        hr {
            border: 0;
            border-top: 1px solid #eee;
            margin: 2rem 0;
        }
    </style>
</head>

<body>

    <main>
        <header>
            <h1>TypeScript Clean Code Constitution</h1>
            <dl>
                <dt>Version</dt>
                <dd>1.1.0 (Strict Enforcement Update)</dd>
                <dt>Context</dt>
                <dd>Feature-Based Architecture (Controller-Service-Repository)</dd>
                <dt>Enforcement</dt>
                <dd><strong>Draconian / CI-Gated</strong> (Violations = Build Failure)</dd>
            </dl>
            <hr>
        </header>

        <section id="core-philosophy">
            <h2>I. The Core Narrative</h2>
            <p><strong>Definition:</strong> Clean Code in TypeScript is defined by Predictability and Type Integrity.
            </p>
            <ol>
                <li>
                    <strong>Type Safety is Documentation:</strong> Do not write comments explaining <em>what</em> a
                    variable is. Define a Type/Interface that makes it self-evident.
                </li>
                <li>
                    <strong>The "Sterile Zone" Principle:</strong> The application core (Service/Repository) is a
                    sterile environment. Data from the outside world (HTTP requests, APIs) must be sanitized, validated,
                    and typed immediately upon entry (at the Controller level).
                </li>
                <li>
                    <strong>Honesty:</strong> The code must be honest about its state. We do not hide errors, and we do
                    not lie about types using <code>any</code>.
                </li>
            </ol>
        </section>

        <hr>

        <section id="architecture">
            <h2>II. Architectural Implementation</h2>
            <p>The codebase follows a strict <strong>Feature-Based Module</strong> pattern.</p>
            <pre><code>
src/features/&lt;feature_name&gt;/
‚îú‚îÄ‚îÄ &lt;feature&gt;.controller.ts  // Gatekeeper: Validates Input (Zod) -> Calls Service
‚îú‚îÄ‚îÄ &lt;feature&gt;.service.ts     // Brain: Pure Logic, DTO in/out, No HTTP objects
‚îú‚îÄ‚îÄ &lt;feature&gt;.repository.ts  // Storage: DB interaction, Returns Entities
‚îú‚îÄ‚îÄ &lt;feature&gt;.routes.ts      // Router: Definitions only
‚îî‚îÄ‚îÄ &lt;feature&gt;.types.ts       // Contracts: Interfaces & DTOs
            </code></pre>
        </section>

        <hr>

        <section id="primary-directives">
            <h2>III. The Primary Directives (Mandatory Rules)</h2>

            <article id="zero-any-policy">
                <h3>A. The "Zero Any" Policy üö´</h3>
                <p>The usage of <code>any</code> defeats the purpose of TypeScript. It is banned in all forms.</p>
                <ul>
                    <li><span class="badge forbidden">FORBIDDEN</span> <strong>Explicit Any:</strong>
                        <code>const x: any</code>.
                    </li>
                    <li><span class="badge forbidden">FORBIDDEN</span> <strong>Stealth Any:</strong>
                        <ul>
                            <li><code>z.any()</code> in Zod Schemas (Use <code>z.unknown()</code>).</li>
                            <li><code>Record&lt;string, any&gt;</code> (Use <code>Record&lt;string, unknown&gt;</code>).
                            </li>
                            <li><code>JSON.parse()</code> without immediate Zod validation/Type Guard.</li>
                        </ul>
                    </li>
                    <li><span class="badge forbidden">FORBIDDEN</span> <strong>Silencers:</strong>
                        <code>// @ts-ignore</code> or <code>eslint-disable</code> (Unless strictly justified with a
                        comment).
                    </li>
                </ul>
            </article>

            <article id="observability">
                <h3>B. Observability & Logging üîá</h3>
                <ul>
                    <li><span class="badge forbidden">FORBIDDEN</span> <strong>Console Log:</strong> Usage of
                        <code>console.log</code>, <code>console.error</code>, or <code>console.warn</code> in source
                        code (`src/`).
                    </li>
                    <li><span class="badge required">REQUIRED</span> <strong>Logger Service:</strong> Use the
                        application's standardized <strong>Logger</strong> adapter (e.g., Winston/Pino wrapper).</li>
                    <li><span class="badge required">REQUIRED</span> <strong>Structured Logs:</strong> Logs must be
                        structured objects, not random strings, to facilitate observability.</li>
                </ul>
            </article>

            <article id="input-validation">
                <h3>C. Input Validation (The Border Patrol) üõ°Ô∏è</h3>
                <ul>
                    <li><span class="badge required">REQUIRED</span> <strong>Zod Validation:</strong> All external
                        inputs (API bodies, params) must be validated using <strong>Zod</strong> schemas at the
                        Controller level.</li>
                    <li><span class="badge required">REQUIRED</span> <strong>Safe Typed Request:</strong> Use
                        <code>TypedRequest&lt;Params, Res, Body, Query&gt;</code> generic wrappers instead of raw
                        Express Request.
                    </li>
                </ul>
            </article>

            <article id="testing-standards">
                <h3>D. Testing Standards üß™</h3>
                <ul>
                    <li><span class="badge required">REQUIRED</span> <strong>Silence:</strong> Tests must not output
                        logs to the console. Mock the Logger.</li>
                    <li><span class="badge forbidden">FORBIDDEN</span> <strong>Loose Mocks:</strong> Do not mock data
                        using <code>as any</code>. Define partial interfaces or use test data builders.</li>
                    <li><span class="badge required">REQUIRED</span> <strong>Strict Assertions:</strong> Use
                        <code>expect(obj).toEqual(...)</code> over <code>toBeTruthy()</code> to prevent false positives
                        on objects.
                    </li>
                </ul>
            </article>
        </section>

        <hr>

        <section id="edge-case-protocols">
            <h2>IV. Edge Case Protocols</h2>

            <article>
                <h3>Protocol 1: Handling Dynamic Objects</h3>
                <p>If an object has dynamic keys but consistent values, use <code>Record</code> with unknown.</p>
                <pre><code>const config: Record&lt;string, unknown&gt; = { ... }</code></pre>
            </article>

            <article>
                <h3>Protocol 2: The "Safety Harness" (3rd Party Libraries)</h3>
                <p>If an external library returns <code>any</code>, establish a "Casting Boundary" immediately in a
                    dedicated adapter or type file.</p>
                <pre><code>
// Allowed ONLY in adapter/type files:
const result = library.getData() as unknown as ExpectedType;
                </code></pre>
            </article>

            <article>
                <h3>Protocol 3: Array Access Safety</h3>
                <p>Assume array access can always be undefined (TSConfig <code>noUncheckedIndexedAccess</code> is ON).
                </p>
                <pre><code>
const user = users[0]; // Type is User | undefined
if (!user) throw new Error("User not found");
                </code></pre>
            </article>
        </section>

        <hr>

        <section id="modern-syntax">
            <h2>V. Modern Syntax & Style</h2>
            <ul>
                <li><strong>Null Checks:</strong> Use Optional Chaining (<code>?.</code>) and Nullish Coalescing
                    (<code>??</code>).</li>
                <li><strong>Immutability:</strong> Prefer spread operator (<code>...</code>) over mutation.</li>
                <li><strong>Imports:</strong> Sort imports automatically. No empty lines inside import groups.</li>
                <li><strong>Async:</strong> No floating promises. Always <code>await</code> or return.</li>
            </ul>
        </section>

    </main>

</body>

</html>