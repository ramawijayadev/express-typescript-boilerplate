<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Architecture Handbook</title>
	<style>
		/* DESIGN SYSTEM: Clean, Technical, Minimalist. */
		@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap');

		:root {
			--bg-color: #ffffff;
			--text-main: #111827;
			--text-muted: #4b5563;
			--accent-color: #2563eb;
			--border-color: #e5e7eb;
			--code-bg: #f3f4f6;
			--code-text: #be185d;
			--section-bg: #f9fafb;
		}

		html {
			scroll-behavior: smooth;
		}

		body {
			font-family: 'Inter', sans-serif;
			line-height: 1.6;
			color: var(--text-main);
			max-width: 850px;
			margin: 0 auto;
			padding: 60px 24px;
			background-color: var(--bg-color);
		}

		h1,
		h2,
		h3,
		h4 {
			font-weight: 700;
			color: var(--text-main);
			letter-spacing: -0.025em;
		}

		h1 {
			font-size: 3.5rem;
			line-height: 1.1;
			margin-bottom: 0.5rem;
			letter-spacing: -0.04em;
		}

		.subtitle {
			font-size: 1.5rem;
			font-weight: 500;
			color: var(--text-muted);
			margin-bottom: 2rem;
			border-bottom: 1px solid var(--border-color);
			padding-bottom: 2rem;
		}

		h2 {
			font-size: 1.8rem;
			margin-top: 3.5rem;
			margin-bottom: 1.5rem;
			padding-bottom: 0.5rem;
			border-bottom: 2px solid var(--text-main);
		}

		h3 {
			font-size: 1.25rem;
			margin-top: 2rem;
			margin-bottom: 0.75rem;
			color: var(--text-main);
		}

		p {
			margin-bottom: 1.25rem;
			color: var(--text-muted);
		}

		strong {
			color: var(--text-main);
			font-weight: 600;
		}

		ul,
		ol {
			margin-bottom: 1.5rem;
			padding-left: 1.5rem;
			color: var(--text-muted);
		}

		li {
			margin-bottom: 0.5rem;
		}

		blockquote {
			border-left: 4px solid var(--accent-color);
			background-color: var(--section-bg);
			margin: 2rem 0;
			padding: 1rem 1.5rem;
			font-style: italic;
			color: var(--text-main);
			border-radius: 0 4px 4px 0;
		}

		code {
			font-family: 'JetBrains Mono', monospace;
			background-color: var(--code-bg);
			color: var(--code-text);
			padding: 0.2em 0.4em;
			border-radius: 4px;
			font-size: 0.85em;
			font-weight: 500;
		}

		.toc {
			background-color: var(--section-bg);
			padding: 2rem;
			border-radius: 8px;
			border: 1px solid var(--border-color);
			margin-bottom: 4rem;
		}

		.toc h3 {
			margin-top: 0;
			font-size: 0.875rem;
			text-transform: uppercase;
			letter-spacing: 0.05em;
			color: var(--text-muted);
		}

		.toc ul {
			list-style: none;
			padding-left: 0;
			margin-bottom: 0;
		}

		.toc li {
			margin-bottom: 0.5rem;
		}

		.toc a {
			text-decoration: none;
			color: var(--accent-color);
			font-weight: 500;
			transition: color 0.2s;
		}

		.toc a:hover {
			color: var(--text-main);
			text-decoration: underline;
		}

		@media print {
			body {
				padding: 0;
				color: #000;
			}

			h2 {
				break-before: auto;
				page-break-after: avoid;
				border-bottom: 1px solid #000;
			}

			.toc {
				display: none;
			}
		}
	</style>
</head>

<body>

	<header>
		<h1>Architecture Handbook</h1>
		<div class="subtitle">
			Technical architecture guide for building production-grade, scalable, and maintainable backend applications.
		</div>
	</header>

	<nav class="toc">
		<h3>Table of Contents</h3>
		<ul>
			<li><a href="#intro">1. Purpose & Scope</a></li>
			<li><a href="#mental-model">2. Mental Model</a></li>
			<li><a href="#platform-core">3. Platform / Runtime Core</a></li>
			<li><a href="#domain-api">4. Domain & API Layer</a></li>
			<li><a href="#data-integration">5. Data & Integration Layer</a></li>
			<li><a href="#security">6. Security & Access Layer</a></li>
			<li><a href="#communication">7. Communication Layer</a></li>
			<li><a href="#observability">8. Observability & Operations</a></li>
			<li><a href="#dx-quality">9. Developer Experience & Quality</a></li>
			<li><a href="#advanced">10. Advanced Topics</a></li>
			<li><a href="#summary">11. Summary</a></li>
		</ul>
	</nav>

	<section id="intro">
		<h2>1. Purpose & Scope</h2>
		<p>This document serves as the technical "North Star" to ensure that applications built are:</p>
		<ul>
			<li><strong>Production-grade:</strong> Ready to serve real users, stable, and secure.</li>
			<li><strong>Scalable:</strong> Relevant for small teams (MVP) up to large-scale operations.</li>
			<li><strong>Technology-agnostic:</strong> Focused on structural concepts, not just specific frameworks.</li>
		</ul>
	</section>

	<section id="mental-model">
		<h2>2. Mental Model</h2>
		<p>The backend application is conceptualized as a combination of 7 primary layers:</p>
		<ol>
			<li><strong>Platform / Runtime Core</strong> (Foundation)</li>
			<li><strong>Domain & API Layer</strong> (Business Logic)</li>
			<li><strong>Data & Integration Layer</strong> (Storage & External)</li>
			<li><strong>Security & Access Layer</strong> (Safety)</li>
			<li><strong>Communication Layer</strong> (Protocol)</li>
			<li><strong>Observability & Operations</strong> (Monitoring)</li>
			<li><strong>Developer Experience & Quality</strong> (Tooling)</li>
		</ol>
		<blockquote>
			Some aspects are <strong>cross-cutting concerns</strong> (such as Security, Logging, and Config) that
			permeate
			multiple layers, but their policies are defined in specific layers.
		</blockquote>
	</section>

	<section id="platform-core">
		<h2>3. Platform / Runtime Core</h2>
		<p>The technical foundation layer. All requests rely on this component.</p>

		<h3>3.1. Config & Environment Management</h3>
		<p><strong>Principle:</strong> Explicit Configuration.</p>
		<ul>
			<li><strong>Environment Variables:</strong> Store secrets (DB URL, API Keys) in the environment, not in the
				code.
			</li>
			<li><strong>Schema Validation:</strong> The application must fail to start if mandatory configuration is
				invalid.</li>
			<li><strong>Abstraction:</strong> Use a single global configuration object (singleton) within the app.</li>
		</ul>
		<p><strong>Implementation:</strong> Uses Zod for environment variable validation in
			<code>src/app/env.ts</code>. Configurations are grouped modularly by domain in <code>src/config/</code>
			(app, auth,
			database, logging, mail, queue, swagger).
		</p>

		<h3>3.2. HTTP Server & Routing</h3>
		<p>Framework initialization and global routing. Ensure consistent URL structure (e.g., <code>/api/v1</code>) and
			split routing per feature module.</p>
		<p><strong>Implementation:</strong> The Express app is bootstrapped in <code>src/app/app.ts</code> with
			centralized routing
			in <code>src/core/http/router.ts</code>. All endpoints are mounted at <code>/api/v1</code>. Swagger UI is
			available
			at the root (<code>/</code>) for non-production environments.</p>

		<h3>3.3. Global Middlewares</h3>
		<p>Technical logic executed before business logic:</p>
		<ul>
			<li>Body parser, CORS, Security headers (Helmet).</li>
			<li>Request ID generator (for tracing).</li>
			<li>Rate limiter.</li>
		</ul>
		<p><strong>Implementation:</strong> The complete middleware stack is defined in
			<code>src/core/http/middlewares/index.ts</code>:
		</p>
		<ul>
			<li><strong>Helmet:</strong> HTTP security headers with CSP policy (dynamic content allowed for Swagger UI).
			</li>
			<li><strong>CORS:</strong> Origin configuration via env vars with credentials support.</li>
			<li><strong>HPP:</strong> Protection against HTTP Parameter Pollution.</li>
			<li><strong>Rate Limiting:</strong> Configurable window & max requests (disabled in test environments).</li>
			<li><strong>Body Size Limit:</strong> 10kb limit to prevent DoS attacks.</li>
			<li><strong>Input Sanitization:</strong> Custom middleware to prevent NoSQL/SQL injection.</li>
			<li><strong>Request ID:</strong> UUID generation or propagation from <code>x-request-id</code> header.</li>
			<li><strong>Request Logger:</strong> Structured logging for every HTTP request (method, path, status,
				duration).</li>
		</ul>

		<h3>3.4. Error Handling Strategy</h3>
		<p>Standardizing error representation to the client:</p>
		<ul>
			<li><strong>Error Model:</strong> Standard JSON structure (<code>success</code>, <code>message</code>,
				<code>statusCode</code>, <code>errors</code> for validation, <code>requestId</code>).
			</li>
			<li><strong>Error Mapping:</strong> Mapping error types to HTTP status codes (400, 404, 500) using the
				<code>AppError</code> class.
			</li>
			<li><strong>Global Handler:</strong> Centralized catch-all for logging (separate from user response) and
				sanitization.</li>
		</ul>
		<p><strong>Implementation:</strong> The <code>AppError</code> class in
			<code>src/shared/errors/AppError.ts</code>
			handles operational errors. The global error handler in <code>src/core/http/error-handler.ts</code> handles
			AppError, ZodError (validation), and Prisma errors. Response helpers are located in
			<code>src/shared/http/api-response.ts</code> (ok, created, clientError, validationError, serverError).
		</p>

		<h3>3.5. Health Checks & Lifecycle</h3>
		<ul>
			<li><strong>Liveness Probe:</strong> Checks if the process is alive (for restart policies).</li>
			<li><strong>Readiness Probe:</strong> Checks if the app is ready to accept traffic (stops traffic if DB is
				down).</li>
			<li><strong>Graceful Shutdown:</strong> Stops new requests, finishes in-flight requests, and closes DB
				connections
				cleanly before termination.</li>
		</ul>
		<p><strong>Implementation:</strong> Endpoint <code>GET /api/v1/health</code> in
			<code>src/modules/platform/health/health.routes.ts</code>. The response includes server status, version,
			timestamp, and job metrics (failed job count with alert threshold). Graceful shutdown in
			<code>src/app/server.ts</code> handles SIGINT/SIGTERM by closing the HTTP server, database connections,
			and background job workers.
		</p>
	</section>

	<section id="domain-api">
		<h2>4. Domain & API Layer</h2>
		<p>The layer containing Business Logic and HTTP Contracts.</p>

		<h3>4.1. Domain Entities / Models</h3>
		<p>Pure business concepts (User, Order) and their rules. Must not depend on HTTP framework details.</p>

		<h3>4.2. Service / Use Case Layer</h3>
		<p>Orchestrates business flow (Register, Checkout). Connects validation, repositories, and other logic.</p>

		<h3>4.3. Validation (Request & Domain)</h3>
		<ul>
			<li><strong>Request Validation:</strong> Checks input format (Zod/Joi Schema).</li>
			<li><strong>Domain Validation:</strong> Checks business rules (e.g., Insufficient stock).</li>
		</ul>

		<h3>4.4. CRUD Patterns & Response</h3>
		<p>Standardization of Create, Read, Update, Delete operations:</p>
		<ul>
			<li>Consistent naming conventions.</li>
			<li><strong>Response Format:</strong> Uniform success structure (<code>data</code>, <code>meta</code> for
				pagination).</li>
		</ul>

		<h3>4.5. Routing & Controllers</h3>
		<p>Controllers are strictly responsible for receiving input, calling services, and mapping results to HTTP
			responses.
			<strong>Avoid business logic in controllers.</strong>
		</p>

		<h3>4.6. API Versioning</h3>
		<p>Use a versioning strategy (URL prefix <code>/v1/</code>) so that API evolution does not break existing
			clients.</p>
	</section>

	<section id="data-integration">
		<h2>5. Data & Integration Layer</h2>

		<h3>5.1. Database & Repository Pattern</h3>
		<p>Use the <strong>Repository Pattern</strong> (via Prisma ORM) to isolate the domain from database query
			details,
			facilitating testing and maintenance.</p>
		<p><strong>Implementation:</strong> Prisma Client in <code>src/core/database/connection.ts</code> with the
			PostgreSQL adapter (<code>@prisma/adapter-pg</code>) for serverless compatibility. The schema in
			<code>prisma/schema.prisma</code> includes User, UserSession, PasswordResetToken, EmailVerificationToken,
			and Example models. The repository pattern is consistent across all modules (e.g.,
			<code>auth.repository.ts</code>,
			<code>users.repository.ts</code>).
		</p>

		<h3>5.2. Caching Strategy</h3>
		<p>Reducing data latency (Redis). Define clear <strong>TTL</strong> and <strong>Invalidation</strong> strategies
			when data changes.</p>
		<p><strong>Status:</strong> Redis client (ioredis) is available and used for the queue infrastructure. A caching
			layer has not yet been explicitly implemented.</p>

		<h3>5.3. Async Jobs (Message Queue)</h3>
		<p>Handling heavy processes (email, reports) in the background using a Queue (BullMQ/Redis) and separate Worker
			processes.
		</p>
		<p><strong>Implementation:</strong> BullMQ queue system in <code>src/core/queue/index.ts</code> featuring:</p>
		<ul>
			<li><strong>Email Queue:</strong> Dedicated queue for email jobs (verification, password reset).</li>
			<li><strong>Dead Letter Queue (DLQ):</strong> Separate queue for failed jobs after retries are exhausted.
			</li>
			<li><strong>Worker:</strong> Background worker in <code>src/jobs/index.ts</code> with concurrency set to 5.
			</li>
			<li><strong>Job Handlers:</strong> Send email (<code>send-email.job.ts</code>), cleanup old failed jobs
				(<code>cleanup-failed-jobs.job.ts</code>).</li>
			<li><strong>Retry Policy:</strong> Configurable attempts with automatic DLQ migration.</li>
			<li><strong>Job Management API:</strong> Admin endpoints at <code>/api/v1/jobs</code> to list, retry,
				remove, and cleanup failed jobs.</li>
			<li><strong>Health Monitoring:</strong> Job metrics included in the health check endpoint with alert
				thresholds.
			</li>
		</ul>

		<h3>5.4. File & Object Storage</h3>
		<p>Store binary files (images, documents) in Object Storage (S3/MinIO), not in the database. The database only
			stores the URL/Key.</p>
		<p><strong>Status:</strong> Storage abstraction layer is available in <code>src/core/storage/index.ts</code>,
			but
			concrete implementations for S3/local storage and file upload endpoints are pending.</p>

		<h3>5.5. Search Engine Integration</h3>
		<p>If complex search features are required (Full-text search), sync data to a dedicated search engine
			(Elasticsearch/MeiliSearch).</p>
		<p><strong>Status:</strong> Not yet implemented.</p>

		<h3>5.6. External API Clients</h3>
		<p>Wrappers for third-party services (Payment, SMS). Focus on handling <strong>Timeouts</strong> and
			<strong>Retry</strong> strategies.
		</p>
		<p><strong>Status:</strong> Axios is available as an HTTP client, but specific wrappers for external
			APIs are not yet created.</p>
	</section>

	<section id="security">
		<h2>6. Security & Access Layer</h2>

		<h3>6.1. Authentication</h3>
		<p>User identification (JWT, Session, OAuth). Ensure secure token validation mechanisms.</p>
		<p><strong>Implementation:</strong> Dual-token JWT system in <code>src/modules/platform/auth/</code>:</p>
		<ul>
			<li><strong>Access Token:</strong> Short-lived JWT (configurable expiry) for authorization.</li>
			<li><strong>Refresh Token:</strong> Long-lived hashed token stored in the database (UserSession table).</li>
			<li><strong>Token Rotation:</strong> Refresh tokens are hashed and rotated upon every refresh for security.
			</li>
			<li><strong>Session Management:</strong> Tracking user agent, IP address, and last used timestamp.</li>
			<li><strong>Account Locking:</strong> Failed login tracking with automatic account lock after a threshold.
			</li>
			<li><strong>Email Verification:</strong> Token-based with expiry.</li>
			<li><strong>Password Reset Flow:</strong> Secure token generation and validation.</li>
		</ul>

		<h3>6.2. Authorization</h3>
		<p>Access control (RBAC/Permission-based). Determining "who is allowed to do what" on specific resources.</p>
		<p><strong>Status:</strong> Authentication middleware (<code>authenticate.middleware.ts</code>) is available to
			verify JWTs and attach the user to the request context. RBAC/permission systems are not yet implemented.</p>

		<h3>6.3. Security Hardening</h3>
		<p>Implementation of additional defense layers: Rate Limiter, Input Sanitization (XSS/SQLi), strict CORS policy,
			and
			Brute-force protection.</p>
		<p><strong>Implementation:</strong> Comprehensive security middleware stack (see section 3.3). Password hashing
			uses <strong>Argon2</strong> (more secure than bcrypt). Timing-safe comparisons for token validation.</p>

		<h3>6.4. Secrets Management</h3>
		<p>Management of encryption and keys. <strong>Never commit secrets to the repo.</strong> Use a Secret Manager
			or encrypted Env Vars.</p>
		<p><strong>Implementation:</strong> All secrets via environment variables with validation via Zod schema. JWT
			secrets, database URLs, Redis credentials, and SMTP credentials managed via <code>.env</code> (gitignored).
			<code>.env.example</code> is provided as a template.
		</p>

		<h3>6.5. Audit Log</h3>
		<p>Recording critical activity trails ("Who", "Did What", "When") for forensics, security, and compliance.</p>
		<p><strong>Status:</strong> Not yet implemented. Structured logging is available, but there is no dedicated
			audit
			log table or tracking for sensitive operations.</p>
	</section>

	<section id="communication">
		<h2>7. Communication Layer</h2>
		<ul>
			<li><strong>HTTP REST/GraphQL:</strong> Standard request-response communication.</li>
			<li><strong>Real-Time (WebSocket/SSE):</strong> For live notifications or chat.</li>
			<li><strong>Event-Driven (Pub/Sub):</strong> Integrations between modules that are <em>loosely-coupled</em>
				via an event
				bus.
			</li>
		</ul>
	</section>

	<section id="observability">
		<h2>8. Observability & Operations</h2>

		<h3>8.1. Structured Logging</h3>
		<p>Logs in JSON format. Must include context (RequestId, UserId) and appropriate Log Levels.</p>
		<p><strong>Implementation:</strong> Pino logger in <code>src/core/logging/logger.ts</code> featuring:</p>
		<ul>
			<li><strong>JSON Output:</strong> Structured logging for easy parsing (production).</li>
			<li><strong>Pretty Print:</strong> Human-readable format for development (pino-pretty).</li>
			<li><strong>Request Correlation:</strong> Automatic request ID attachment to every log entry.</li>
			<li><strong>Context Enrichment:</strong> Support for adding contextual data (userId, path, etc.).</li>
			<li><strong>Log Rotation:</strong> Pino-roll configured for daily rotation and retention policy.</li>
			<li><strong>Log Levels:</strong> debug, info, warn, error properly utilized throughout the codebase.</li>
		</ul>

		<h3>8.2. Metrics & Monitoring</h3>
		<p>Monitoring system health: Throughput (RPS), Latency (p95, p99), Error Rate, and Resource Usage.</p>
		<p><strong>Implementation:</strong> Metrics initialization in <code>src/core/observability/metrics.ts</code>
			(called during server bootstrap). Infrastructure is ready for metrics collection.</p>

		<h3>8.3. Tracing</h3>
		<p>Using <code>TraceId</code> / <code>CorrelationId</code> to track the request journey across various
			system components.</p>
		<p><strong>Implementation:</strong> Request ID middleware generates a UUID for every request. Tracing
			initialization in <code>src/core/observability/tracing.ts</code>. IDs are propagated via HTTP headers
			(<code>x-request-id</code>) and included in all log entries and API responses.</p>

		<h3>8.4. Alerting Hooks</h3>
		<p>Automatic notifications (Slack/PagerDuty) when critical metrics (Error rate, Latency) exceed reasonable
			thresholds.
		</p>
		<p><strong>Status:</strong> Health check endpoint provides job metrics with alert thresholds, but integration
			with
			external alerting systems is not yet implemented.</p>
	</section>

	<section id="dx-quality">
		<h2>9. Developer Experience & Quality</h2>

		<h3>9.1. Automated Testing Strategy</h3>
		<p>Testing pyramid to ensure quality:</p>
		<ul>
			<li><strong>Unit Test:</strong> Smallest logic isolated.</li>
			<li><strong>Integration Test:</strong> Interaction between modules/DB.</li>
			<li><strong>E2E Test (API Flow):</strong> Full user scenarios from start to finish.</li>
			<li><strong>Load/Stress Test (k6):</strong> Performance and load resilience testing.</li>
		</ul>
		<p><strong>Implementation:</strong> Vitest as the test runner in <code>src/tests/</code>:</p>
		<ul>
			<li><strong>Vitest:</strong> Modern test runner with Vite-native compilation (faster than Jest).</li>
			<li><strong>Supertest:</strong> HTTP assertion library for integration testing.</li>
			<li><strong>Test Organization:</strong> Feature-based with <code>__tests__</code> folders in every module.
			</li>
			<li><strong>Naming Convention:</strong> <code>*.unit.spec.ts</code>, <code>*.integration.spec.ts</code>,
				<code>*.e2e.spec.ts</code>.
			</li>
			<li><strong>Setup:</strong> Global test setup in <code>src/tests/setup.ts</code> for database connection
				and cleanup.</li>
			<li><strong>Coverage:</strong> Auth flow, user journey, API response format, error handling.</li>
		</ul>

		<h3>9.2. Documentation</h3>
		<p>OpenAPI/Swagger that is <strong>generated from code</strong> (via zod-to-openapi) serving as the contract
			(Single Source
			of Truth) with Frontend/Client.</p>
		<p><strong>Implementation:</strong> Code-first OpenAPI documentation:</p>
		<ul>
			<li><strong>@asteasolutions/zod-to-openapi:</strong> Generates spec from Zod schemas.</li>
			<li><strong>Registry Pattern:</strong> Each route file exports an OpenAPIRegistry with path definitions.
			</li>
			<li><strong>Swagger UI:</strong> Mounted at the root (<code>/</code>) for non-production environments.</li>
			<li><strong>Config:</strong> Swagger spec generator in <code>src/config/swagger.ts</code>.</li>
			<li><strong>Auto-sync:</strong> Documentation is always in sync with validation schemas.</li>
		</ul>

		<h3>9.3. Code Quality & Standards</h3>
		<p>Automated Linter (ESLint) and Formatter (Prettier) via <strong>Git Hooks</strong> (Husky) for consistent code
			standards.</p>
		<p><strong>Implementation:</strong> ESLint + Prettier with TypeScript support. Husky + lint-staged configured
			for pre-commit hooks. Import sorting, no unused vars, and consistent naming enforced.</p>

		<h3>9.4. CI Pipeline & Local Dev</h3>
		<ul>
			<li><strong>CI Pipeline:</strong> Automatically runs tests and linting before merge.</li>
			<li><strong>Local Environment:</strong> Easy and standardized local development setup using
				<strong>Docker</strong>.
			</li>
		</ul>
		<p><strong>Implementation:</strong> Docker Compose setup in <code>docker-compose.yml</code> for PostgreSQL and
			Redis. Development workflow with <code>pnpm dev</code> for hot reload via nodemon + tsx. Scripts are
			available for db migration, testing, and linting.</p>
	</section>

	<section id="advanced">
		<h2>10. Advanced Topics</h2>
		<p>Development references for larger scales:</p>
		<ul>
			<li><strong>Performance Strategy:</strong> Aggressive caching, stateless scaling.</li>
			<li><strong>Data Lifecycle:</strong> Data retention and backup policies.</li>
			<li><strong>Multi-Tenancy:</strong> Data isolation for SaaS B2B applications.</li>
			<li><strong>Feature Flags:</strong> Incremental feature releases without redeployment.</li>
			<li><strong>CQRS:</strong> Separation of read and write models for high performance.</li>
			<li><strong>ADR (Architectural Decision Records):</strong> Historical documentation of technical decisions.
			</li>
			<li><strong>Operational Playbook:</strong> Standard checklists for handling production incidents.</li>
		</ul>
	</section>

	<section id="summary">
		<h2>11. Summary</h2>
		<p>A <strong>production-grade</strong> backend application is an orchestration of all the layers above. This
			document
			serves as a conceptual map to ensure code implementation remains directed, consistent, and of high quality.
		</p>
	</section>

</body>

</html>